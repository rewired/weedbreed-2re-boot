# Centralize validation schemas in the engine

Move the Zod validation schemas from the @wb/facade package to the @wb/engine
package. This collocates the schemas with the domain types they validate,
creating a single source of truth and improving maintainability.
Examples:
packages/facade/src/schemas/world.ts

Solution Walkthrough:
Before:

```ts
import { z } from 'zod';

// packages/engine/src/types.ts
export type Company = { ... };
export type Room = { ... };
// ... etc

// packages/facade/src/schemas/world.ts
import { type Company, type Room } from '@wb/engine';
import { z } from 'zod';

export const roomSchema: z.ZodType<Room> = ...;
export const companySchema: z.ZodType<Company> = ...;
export function parseCompanyWorld(input: unknown) { ... }

// packages/facade/src/index.ts
import { parseCompanyWorld } from './schemas/world.js';
initializeFacade(options) {
  const companyWorld = parseCompanyWorld(options.world);
  // ...
}
```

After:

```ts
// packages/engine/src/schemas/world.ts
import { z } from 'zod';
export type Company = { ... };
export type Room = { ... };

export const roomSchema: z.ZodType<Room> = ...;
export const companySchema: z.ZodType<Company> = ...;
export function parseCompanyWorld(input: unknown) { ... }

// packages/facade/src/index.ts
import { parseCompanyWorld } from '@wb/engine';

initializeFacade(options) {
  const companyWorld = parseCompanyWorld(options.world);
  // ...
}
```

Why: This is a strong architectural suggestion that correctly identifies that domain validation logic (Zod schemas) is misplaced in the facade instead of the engine, improving long-term maintainability. This is an ADR. Documentation where affected bei this ADR.

---

# Enforce that growrooms must contain zones

Add a validation rule to the roomSchema to ensure that any room with the purpose
'growroom' contains at least one zone.

packages/facade/src/schemas/world.ts

```ts
 export const roomSchema: z.ZodType<Room> = domainEntitySchema
   .merge(sluggedEntitySchema)
   .merge(spatialEntitySchema)
   .extend({
     purpose: z.enum([...ROOM_PURPOSES]),
     zones: z.array(zoneSchema).readonly(),
     devices: z.array(roomDeviceSchema).readonly()
   })
   .superRefine((room, ctx) => {
+    if (room.purpose === 'growroom' && room.zones.length === 0) {
+      ctx.addIssue({
+        code: z.ZodIssueCode.custom,
+        message: 'A growroom must contain at least one zone.',
+        path: ['zones']
+      });
+    }
     if (room.purpose !== 'growroom' && room.zones.length > 0) {
       ctx.addIssue({
         code: z.ZodIssueCode.custom,
         message: 'Only growrooms may contain zones.',
         path: ['zones']
       });
     }
   });
```

Why: The suggestion correctly identifies a missing validation rule that improves the data integrity of the new schema, which is the main purpose of the PR.

---

# Use structuredClone for robust deep cloning

Replace JSON.parse(JSON.stringify()) with structuredClone() in the cloneWorld
test helper for a more robust deep-cloning implementation.

packages/facade/tests/unit/schemas/worldSchema.test.ts [98]

```ts
-const cloneWorld = () => JSON.parse(JSON.stringify(BASE_WORLD));
+const cloneWorld = () => structuredClone(BASE_WORLD);
```

Why: The suggestion improves test code robustness by replacing a fragile cloning method with the modern and more reliable structuredClone API, which is a good practice.

---

# Create invalid test data immutably

Refactor the test to create invalid data immutably using object spreading
instead of directly mutating a cloned object, making the test less brittle.

packages/facade/tests/unit/schemas/worldSchema.test.ts

```ts
 it('rejects devices that declare an incorrect placement scope for the zone level', () => {
-  const invalidWorld: any = cloneWorld();
-  invalidWorld.structures[0].rooms[0].zones[0].devices[0].placementScope = 'room';
+  const world = cloneWorld();
+  const invalidWorld = {
+    ...world,
+    structures: [
+      {
+        ...world.structures[0],
+        rooms: [
+          {
+            ...world.structures[0].rooms[0],
+            zones: [
+              {
+                ...world.structures[0].rooms[0].zones[0],
+                devices: [
+                  {
+                    ...world.structures[0].rooms[0].zones[0].devices[0],
+                    placementScope: 'room' as const
+                  }
+                ]
+              }
+            ]
+          }
+        ]
+      }
+    ]
+  };
 
   const result = companySchema.safeParse(invalidWorld);
 
   expect(result.success).toBe(false);
   expect(result.success ? [] : result.error.issues.map((issue) => issue.path)).toContainEqual([
     'structures',
     0,
     'rooms',
     0,
     'zones',
     0,
     'devices',
     0,
     'placementScope'
   ]);
 });

```

Why: The suggestion proposes a more robust, immutable pattern for creating test data, but the proposed code is significantly more verbose and harder to read for a simple change.
Create invalid test data immutably

---

# Enforce a 24-hour light cycle

Add a superRefine check to the lightScheduleSchema to ensure that the sum of
onHours and offHours is exactly 24.

packages/facade/src/schemas/world.ts

```ts
-export const lightScheduleSchema: z.ZodType<LightSchedule> = z.object({
-  onHours: finiteNumber.min(0, 'onHours cannot be negative.'),
-  offHours: finiteNumber.min(0, 'offHours cannot be negative.'),
-  startHour: finiteNumber.min(0, 'startHour cannot be negative.')
-});
+export const lightScheduleSchema: z.ZodType<LightSchedule> = z
+  .object({
+    onHours: finiteNumber.min(0, 'onHours cannot be negative.'),
+    offHours: finiteNumber.min(0, 'offHours cannot be negative.'),
+    startHour: finiteNumber.min(0, 'startHour cannot be negative.')
+  })
+  .superRefine((schedule, ctx) => {
+    if (schedule.onHours + schedule.offHours !== 24) {
+      ctx.addIssue({
+        code: z.ZodIssueCode.custom,
+        message: 'The sum of onHours and offHours must be 24.'
+      });
+    }
+  });
```

Why: The suggestion correctly identifies a missing business rule in the new schema validation and proposes a valid implementation, improving data integrity.
Enforce a 24-hour light cycle

---

# Use a direct assignment with type casting

In the test file, replace Reflect.set with a direct property assignment using an
any type cast to simplify how invalid data is created for testing.

packages/facade/tests/unit/schemas/worldSchema.test.ts

```ts
-Reflect.set(targetDevice as Record<string, unknown>, 'placementScope', 'room');
+(targetDevice as any).placementScope = 'room';
```

Why: The suggestion offers a minor code style improvement for a test file, making the intentional type violation slightly more direct, but it has no impact on functionality.
