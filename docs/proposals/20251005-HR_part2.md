# Weed Breed — Workforce 1.1 Proposal (On‑Demand Market Scan)

> **Scope:** Aktualisierte, konsolidierte Fassung von *Workforce 1.0* mit **rein manuellem Arbeitsmarkt‑Scan**, neuen Defaults (**cooldown 30 Tage**, **poolSize 16**), deterministischem **scanCounter**, Payroll‑/Raise‑Regeln und vollständiger Trait‑Integration. SEC‑konform (per‑hour Engine‑Skala, keine UI‑%).

---

## 0) Core Assumptions

* **Kein Bewerbungsprozess**: Spieler triggert **Arbeitsmarkt‑Scan** on‑demand. **Keine Auto‑Scans**.
* **Cooldown**: `marketScanPeriod_days = 30` als **Mindestabstand** zwischen **manuellen** Scans **pro Struktur**.
* **Kosten**: `marketScanCost_cc = 1000` pro Scan.
* **Pool**: `poolSize = 16`. Kandidaten gültig **bis zum nächsten manuellen Scan**.
* **Kandidaten** ephemer/deterministisch; **Employees** persistent in der Simulation.
* **Skill‑Komposition je Kandidat**: **1 Hauptskill + 2 Nebenskills**; alle übrigen Skills = **0**.
  Ranges: Main **0.25–0.50**, Secondary **0.01–0.35** (geclamped).
* **Raises**: frühestens **180** Sim‑Tage nach Start; danach **Cooldown 180 ± jitter (deterministisch)**.
* **Raise‑Reaktionen**: Accept (Morale +), Bonus (Morale +), Ignore (Morale −); alle resetten den Raise‑Cooldown.
* **Kündigung** jederzeit möglich (optional Abfindung, Team‑Morale‑Ripple).
* **Traits**: 1–2 Traits/Employee, deterministisch zugewiesen; Effekte auf Taskdauer, Fehler, Fatigue, Lernen, Geräteverschleiß, Kontamination.
* **Determinismus**: alle Zufälle via `createRng(seed, streamId)`.

---

## 1) Arbeitsmarkt‑Scan — On‑Demand Design

**Trigger & Cooldown**

* Spieler klickt **„Arbeitsmarkt sichten (1000)“**.
* Scan nur zulässig, wenn `nowSimDay − lastScanDay[structureId] ≥ 30`.
* Optional konfigurierbare Early‑Scan‑Freigabe mit Aufpreis (default **deaktiviert**).

**Determinismus & IDs**

```ts
state.workforce.lastScanDay[structureId]?: number;
state.workforce.scanCounter[structureId]: number; // init 0, ++ pro **manual** scan

// RNG Streams
poolStreamId           = `workforce:scan:${structureId}:${scanCounter}`
candidateStreamId(k)   = `workforce:candidate:${structureId}:${scanCounter}:${k}`
```

* **Kein** `floor(simDay/period)` mehr; der **scanCounter** erhöht sich **nur** bei manuellem Scan → identische Pools bei identischer Trigger‑Historie.

**Pool‑Lifecycle & Hiring**

* Ein Scan erzeugt **poolSize = 16** Kandidaten.
* Pool bleibt bis zum **nächsten** manuellen Scan bestehen (keine zeitbasierte Verfallslogik im MVP).
* **Hire** ist **sofort**; Employee spawnt im **nächsten Tick** mit Rollenschedule.

**UI/UX**

* Button zeigt Kosten & Cooldown‑Hinweis; Pool als Grid (16 Karten) mit Skills/Traits/Rate‑Hinweis.
* Telemetrie: `telemetry.hiring.market_scan.completed.v1 { structureId, simDay, scanCounter, poolSize:16, cost_cc:1000 }`.

---

## 2) Kandidaten — Skills & Traits

**Skills**

* Pro Kandidat **genau 3** Skills: 1× `main`, 2× `secondary`.
* Werte: Main **0.25–0.50**, Secondary **0.01–0.35**; restliche Skills implizit 0.

**Types**

```ts
interface CandidateSkills {
  main: { slug: SkillSlug; value01: number };
  secondary: [ { slug: SkillSlug; value01: number }, { slug: SkillSlug; value01: number } ];
}
function toSkillMap(cs: CandidateSkills): Record<SkillSlug, number> { /* absent → 0 */ }
```

**Traits (Vorschlag, deckungsgleich zu traits.json)**

* Positiv: `green_thumb`, `night_owl`, `quick_learner`, `optimist`, `gearhead`, `frugal`, `meticulous`
* Negativ: `clumsy`, `slacker`, `pessimist`, `forgetful`, `demanding`, `slow_learner`
* Zuweisung beim Hire‑Spawn: 1–2 Traits, `strength01 ∈ [0.3..0.7]`, Konflikte ausgeschlossen.

---

## 3) Payroll & Raises

**Formel (neutral, pro Stunde)**

```
baseRate_per_h = (5 + 10×relevantSkill)
                 × locationIndex
                 × roleBaseMult
                 × experienceMult
                 × laborMarketFactor

rate_per_minute = (baseRate_per_h × otMultiplier × timePremiumMult)/60
```

* OT nach Basistagesstunden: `otMultiplier = 1.25` (Cap +5h).
* Night/Weekend‑Premium optional.
* Tagesabschluss mit Banker’s Rounding.

**Raise‑Cadence & Reaktionen**

* Eligibility: `employmentStart + 180`.
* Cooldown: `lastDecision + 180 ± jitter` mit Stream `workforce:employee:<uuid>:raiseCadence`.
* Aktionen: **Accept** (Morale `+0.06`, Rate↑), **Bonus** (OPEX einmalig, Morale `+0.04`), **Ignore** (Morale `−0.08`).
* Alle Aktionen setzen den Cooldown neu; Telemetrie für jede Aktion.

**Termination**

* `workforce.employee.terminate { employeeId, reasonSlug }` → wirksam zum nächsten Tick; optional Abfindung; optional Team‑Ripple (−0.02/same structure).

---

## 4) Trait‑Engine — Effekte & Hooks

**Effect‑Signatur**

```ts
interface TraitEffectInput { /* tick_h, simDay, roleSlug, task, employee, device, economy */ }
interface TraitEffectOutput {
  duration_h?; errorRate01?; contamRisk01?;
  fatigueDelta01?; moraleDelta01?; deviceDegradation_per_h?;
  learningRateMult?; salaryExpectationMult?;
}
```

**Faltungsreihenfolge & Merging**

1. Speed → 2) Error/Quality → 3) Fatigue/Morale → 4) Device → 5) Learning/Salary.
   Multiplikativ für Raten/Multiplikatoren, additiv für Deltas; Clamps [0..1], Caps 20–25%.

**Beispiel‑Mapping**

* `green_thumb`: bei plantCare/irrigation Dauer −8%·s, Fehler −10%·s.
* `night_owl`: nachts Dauer/Fehler bis −12%·s (anteilig).
* `quick_learner/slow_learner`: ±15%·s XP.
* `optimist/pessimist`: Morale‑Aura ±0.001 (self) / ±0.002 (team) pro Tick.
* `gearhead` (Maintenance): Geräteverschleiß −20%·s.
* `meticulous`: Kontamination −15%·s, Dauer +4%·s.
* `slacker`: Dauer +10%·s, FatigueΔ +0.01·s.
* `clumsy/forgetful`: +Fehler/+Dauer bei Maintenance/Logistics/Training.
* `frugal/demanding`: Salary‑Expectation‑Hint ±8–10%·s (MVP UI‑only).

**Hooks**

* TaskRunner (Start & pro Tick), DeviceWear, Quality/Health, XP‑Engine, Economy (Bonus‑OPEX).

---

## 5) APIs, Telemetrie, Read‑Models

**Façade‑Intents**

* `hiring.market.scan { structureId }`
* `hiring.market.hire { candidateRef }`
* `workforce.raise.accept|bonus|ignore { employeeId, ... }`
* `workforce.employee.terminate { employeeId, reasonSlug }`

**Read‑Models**

* `HiringMarket`: `{ lastScanDay, scanCounter, pool[] }` (Cache, deterministisch rekonstruierbar).
* `PayrollSnapshot`: Base/OT/Bonuses täglich + 7/30‑Tage.
* `TraitBreakdown`: Traits×KPIs Heatmap.

**Telemetry (Auszug)**

* `telemetry.hiring.market_scan.completed.v1 { structureId, simDay, scanCounter, poolSize:16, cost_cc }`
* `telemetry.hiring.employee.onboarded.v1 { employeeId, structureId }`
* `telemetry.workforce.raise.accepted|bonus|ignored.v1`
* `telemetry.workforce.employee.terminated.v1`
* (Debug) `telemetry.traits.effect.applied.v1`

---

## 6) Zod‑Schemas (Skizzen)

```ts
const marketConfig = {
  marketScanPeriod_days: 30,
  marketScanCost_cc: 1000,
  poolSize: 16,
  earlyScan: { allowEarly: false, surchargeFactor: 1.50 }
} as const;

const candidateSkillsSchema = z.object({
  main: z.object({ slug: skillSlug, value01: z.number().min(0.25).max(0.50) }),
  secondary: z.tuple([
    z.object({ slug: skillSlug, value01: z.number().min(0.01).max(0.35) }),
    z.object({ slug: skillSlug, value01: z.number().min(0.01).max(0.35) })
  ])
});

const candidateSchema = z.object({
  id: uuidVBrand,
  structureId: uuidVBrand,
  roleSlug: z.string().min(1),
  skills3: candidateSkillsSchema,
  traits: z.array(traitSlug).default([]),
  expectedBaseRate_per_h: z.number().positive().optional(),
  validUntilScanCounter: z.number().int().nonnegative(),
  scanCounter: z.number().int().nonnegative()
});

const traitInstanceSchema = z.object({ id: traitSlug, strength01: z.number().min(0.0).max(1.0) });
```

---

## 7) Tests (TDD)

**Unit**

* On‑Demand only: **kein** Scan ohne Intent; Cooldown 30 enforced.
* Pool‑Determinismus: gleicher Seed + gleiche scanCounter‑Historie → identische Pools.
* Skills: 1+2‑Regel & Ranges.
* Payroll: Location/Role/Experience/OT/Night/Weekend; Tagesabschluss.
* Raises: 180‑Gate, 180±jitter Cooldown; Accept/Bonus/Ignore + Morale‑Deltas.
* Traits: Wirkung, Caps/Clamps, Komposition.

**Integration**

* Scan→Hire→Task‑Durchlauf mit 16er Pool; KPI‑Vergleich vs Baseline.
* 400+ Tage Raise‑Zyklen mit gemischten Reaktionen.
* Termination: Task‑Cleanup, Team‑Ripple, Vacancy‑Zähler.

**Golden**

* Feature‑Flags **aus** → Golden unverändert. **An** → Runs deterministisch reproduzierbar.

---

## 8) PR‑Slices

1. **Config & Schemas**: Cooldown 30, poolSize 16, scanCounter‑State & RNG‑Keys.
2. **Market Scan Engine**: Intent, Kostenabzug, Pool‑Generator, Read‑Model Cache, Telemetrie.
3. **Payroll Engine**: Formel/OT/Premiums + Tests.
4. **Raises & Responses**: Cadence‑Helper, Accept/Bonus/Ignore, Morale‑Deltas, Events.
5. **Traits Engine & Hooks**: `applyTraitEffects()`, TaskRunner/XP/Device/Quality.
6. **Termination & Ripple**.
7. **Dashboards**: HiringMarket, PayrollSnapshot, TraitBreakdown.
8. **Docs & ADR Update**.

---

## 9) Definition of Done

* ✅ On‑Demand‑Scan (kein Hintergrundlauf), Cooldown 30, Pool 16, deterministischer scanCounter.
* ✅ Payroll & Raises inkl. Reaktionen, Morale‑Clamps, Events.
* ✅ Trait‑Integration (Speed/Error/Fatigue/XP/Wear/Contam) mit Caps/Clamps.
* ✅ Telemetrie & Read‑Models; PR‑Slices lauffähig; Golden‑Runs stabil & deterministisch.
